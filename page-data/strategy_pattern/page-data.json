{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/strategy_pattern","result":{"data":{"post":{"__typename":"MdxPost","slug":"/strategy_pattern","title":"Strategy Pattern - Design Patterns","date":"16.05.2021","tags":null,"description":null,"canonicalUrl":null,"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Strategy Pattern - Design Patterns\",\n  \"date\": \"2021-05-16T00:00:00.000Z\",\n  \"slug\": \"/strategy_pattern\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In this post, I am going to talk about one of the popular design patterns - Strategy pattern. Before learning it let me give you a small introduction about what is design pattern.\"), mdx(\"h3\", null, \"What are design patterns ?\"), mdx(\"p\", null, \"Design patterns are solution for commonly occurring problems in software design. They heavily depend on object oriented principles and are introduced by group of programmers known as \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Design_Patterns\"\n  }, \"Gang of Four\"), \". There are totally 24 design patterns divided among categories such as\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Creational patterns\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Structural patterns\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Behavioral patterns\")), mdx(\"p\", null, \"Without further ado lets see strategy pattern.\"), mdx(\"p\", null, \"According to Wikipedia, Strategy pattern helps in selection of algorithm at runtime.  This pattern lets the algorithm vary independently from clients that use it.\"), mdx(\"p\", null, \"To explain the above, let me describe a most common problem and how it is handled using strategy pattern\"), mdx(\"h3\", null, \"Problem\"), mdx(\"p\", null, \"Lets say we are building an ecommerce application and we have multiple payment options such as credit card, debit card, paypal etc.., Another thing to note is we may get new payment options in future.\"), mdx(\"p\", null, \"For the above problem, we can create a class which would accept a payment algorithm and then let that algorithm decide how the user pays. Payment algorithm can be credit card, debit card etc..,\"), mdx(\"p\", null, \"The advantage in using above approach is Whenever a new payment option comes, we can write a new payment algorithm class and then use that strategy. \"), mdx(\"h3\", null, \"Advantages\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Follows clean code and Open Closed principle\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"It is easy to switch between different algorithms/strategies in runtime.\")), mdx(\"h3\", null, \"Basic Implementation\"), mdx(\"p\", null, \"Lets consider we have a list of elements which we need to sort. It should support any sorting algorithm.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"from abc import ABC, abstractmethod\\nfrom typing import List\\n\\nclass Strategy(ABC):\\n    @abstractmethod\\n    def sort(self, elements):\\n        pass\\n\\nclass BubbleSortStrategy(Strategy):\\n    def sort(self, elements):\\n        # Sorting Logic\\n        print(\\\"Using Bubble Sort\\\")\\n        return sorted(elements)\\n\\nclass InsertionSortStrategy(Strategy):\\n    def sort(self, elements):\\n        # Sorting Logic\\n        print(\\\"Using Insertion Sort\\\")\\n        return sorted(elements)\\n\")), mdx(\"p\", null, \"In the above code we created a base class \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Strategy\"), \" which has abstract method \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sort\"), \" . Now whichever sorting algorithm we require should extend this class and implement the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sort\"), \" method. For the sake of simplicity I have just printed which sorted algorithm we are using instead of actually sorting with that algorithm.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"class Sorter(object):\\n    def __init__(self, elements: List):\\n        self.elements = elements\\n        self._strategy = BubbleSortStrategy()\\n\\n    def set_strategy(self, strategy: Strategy):\\n        self._strategy = strategy\\n\\n    def sort(self):\\n        self.elements = self._strategy.sort(self.elements)\\n        print(self.elements)\\n\\nif __name__=='__main__':\\n    a = Sorter([1, 6, 3, 2, 4, 8, 5, 7])\\n    a.sort()  # By default this uses bubble sorting algorithm\\n    a.set_strategy(InsertionSortStrategy())\\n    a.sort() \\n\")), mdx(\"p\", null, \"As you see in the above code, we created a class called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Sorter\"), \" which has the elements to be sorted and also it has a method \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"set_strategy\"), \" we can provide instance of SortingStrategy as input to that during runtime. It will use the provided strategy to sort the elements.\"), mdx(\"h3\", null, \"Conclusion\"), mdx(\"p\", null, \"This pattern helps in choosing a specific algorithm from multiple algorithms. \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://www.passportjs.org/\"\n  }, \"Passport js\"), \" uses this pattern to select which authentication mechanism to use when a user logs in to web app.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"In this post, I am going to talk about one of the popular design patterns - Strategy pattern. Before learning it let me give you a smallâ€¦","timeToRead":1,"banner":null}},"pageContext":{"slug":"/strategy_pattern","formatString":"DD.MM.YYYY"}},"staticQueryHashes":["3090400250","3090400250","318001574"]}